---
title: '洛谷P7911 [CSP-J 2021] 网络连接'
abbrlink: 65ad2601
date: 2022-12-05 19:52:30
updated: 2022-12-05 19:52:30
tags: 
- OI
- 字符处理
- STL
- C++
- Python
- 算法
categories: OI
cover: https://bu.dusays.com/2023/01/20/63c9e294eb72b.webp
---
本蒟蒻为数不多过了的黄题，祝贺！！！

{% link P7911 [CSP-J 2021] 网络连接,洛谷,https://www.luogu.com.cn/problem/P7911 %}

![](https://bu.dusays.com/2023/01/20/63ca134dbb0be.webp)

# 题面

{% hideToggle 查看题目 %}
# [CSP-J 2021] 网络连接

## 题目描述

TCP/IP 协议是网络通信领域的一项重要协议。今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。

在本问题中，计算机分为两大类：服务机（`Server`）和客户机（`Client`）。服务机负责建立连接，客户机负责加入连接。

需要进行网络连接的计算机共有 $n$ 台，编号为 $1 \sim n$，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。

每台机器在尝试建立或加入连接时需要提供一个地址串。服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。

一个符合规范的地址串应当具有以下特征：

1. 必须形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为非负整数；
2. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$；
3. $a, b, c, d, e$ 均不能含有多余的前导 $0$。

相应地，不符合规范的地址串可能具有以下特征：

1. 不是形如 `a.b.c.d:e` 格式的字符串，例如含有多于 $3$ 个字符 `.` 或多于 $1$ 个字符 `:` 等情况；
2. 整数 $a, b, c, d, e$ 中某一个或多个超出上述范围；
3. 整数 $a, b, c, d, e$ 中某一个或多个含有多余的前导 $0$。

例如，地址串 `192.168.0.255:80` 是符合规范的，但 `192.168.0.999:80`、`192.168.00.1:10`、`192.168.0.1:088`、`192:168:0:1.233` 均是不符合规范的。

如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。

在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。

由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。

如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；如果找不到这样的服务机，则认为这台客户机无法成功加入连接。

请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。

你的任务很简单：在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。

## 输入格式

第一行，一个正整数 $n$。

接下来 $n$ 行，每行两个字符串 $\mathit{op}, \mathit{ad}$，按照编号从小到大给出每台计算机的类型及地址串。

其中 $\mathit{op}$ 保证为字符串 `Server` 或 `Client` 之一，$\mathit{ad}$ 为一个长度不超过 $25$ 的，仅由数字、字符 `.` 和字符 `:` 组成的非空字符串。

每行的两个字符串之间用恰好一个空格分隔开，每行的末尾没有多余的空格。

## 输出格式

输出共 $n$ 行，每行一个正整数或字符串表示第 $i$ 台计算机的连接状态。其中：

如果第 $i$ 台计算机为服务机，则：

1. 如果其提供符合规范的地址串且成功建立连接，输出字符串 `OK`。
2. 如果其提供符合规范的地址串，但由于先前有相同地址串的服务机而无法成功建立连接，输出字符串 `FAIL`。
3. 如果其提供的地址串不是符合规范的地址串，输出字符串 `ERR`。

如果第 $i$ 台计算机为客户机，则：

1. 如果其提供符合规范的地址串且成功加入连接，输出一个正整数表示这台客户机连接到的服务机的编号。
2. 如果其提供符合规范的地址串，但无法成功加入连接时，输出字符串 `FAIL`。
3. 如果其提供的地址串不是符合规范的地址串，输出字符串 `ERR`。

## 样例 #1

### 样例输入 #1

```
5
Server 192.168.1.1:8080
Server 192.168.1.1:8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.1:99999
```

### 样例输出 #1

```
OK
FAIL
1
FAIL
ERR
```

## 样例 #2

### 样例输入 #2

```
10
Server 192.168.1.1:80
Client 192.168.1.1:80
Client 192.168.1.1:8080
Server 192.168.1.1:80
Server 192.168.1.1:8080
Server 192.168.1.999:0
Client 192.168.1.1.8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.999:0
```

### 样例输出 #2

```
OK
1
FAIL
FAIL
OK
ERR
ERR
5
1
ERR
```

## 样例 #3

### 样例输入 #3

```
见附件中的 network/network3.in。
```

### 样例输出 #3

```
见附件中的 network/network3.ans。
```

## 样例 #4

### 样例输入 #4

```
见附件中的 network/network4.in。
```

### 样例输出 #4

```
见附件中的 network/network4.ans。
```

## 提示

**【样例解释 #1】**

计算机 $1$ 为服务机，提供符合规范的地址串 `192.168.1.1:8080`，成功建立连接；

计算机 $2$ 为服务机，提供与计算机 $1$ 相同的地址串，未能成功建立连接；

计算机 $3$ 为客户机，提供符合规范的地址串 `192.168.1.1:8080`，成功加入连接，并连接到服务机 $1$；

计算机 $4$ 为客户机，提供符合规范的地址串 `192.168.1.1:80`，找不到服务机与其连接；

计算机 $5$ 为客户机，提供的地址串 `192.168.1.1:99999` 不符合规范。

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $10$ | 性质 1 2 3 |
| $2 \sim 3$ | $100$ | 性质 1 2 3 |
| $4 \sim 5$ | $1000$ | 性质 1 2 3 |
| $6 \sim 8$ | $1000$ | 性质 1 2 |
| $9 \sim 11$ | $1000$ | 性质 1 |
| $12 \sim 13$ | $1000$ | 性质 2 |
| $14 \sim 15$ | $1000$ | 性质 4 |
| $16 \sim 17$ | $1000$ | 性质 5 |
| $18 \sim 20$ | $1000$ | 无特殊性质 |

“性质 1”为：保证所有的地址串均符合规范；  
“性质 2”为：保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同；  
“性质 3”为：保证任意一台服务机的编号都小于所有的客户机；  
“性质 4”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为不超过 ${10}^9$ 且不含有多余前导 $0$ 的非负整数；  
“性质 5”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为只含有数字的非空字符串。

对于 $100 \%$ 的数据，保证 $1 \le n \le 1000$。

**【提供 hack 数据感谢】**  

- [xyf007](/user/68273)。
{% endhideToggle %}

# 解析-C++做法

想到这是一个比赛题，正式的时候不能用py，故有此法

思路和Python做法类似，但是因为 `C++` 的字符处理比较困难，我选择用全正则

{% p red, 初始化正则表达式的时候一定要放在循环外面！！！否则会T的你怀疑C++和Py的区别！！！！ %}

~~（就因为这个狗的正则初始化搞得我用map和二分弄了好久都没行，本来用数组就行的）~~

放里面：

![](https://bu.dusays.com/2023/01/20/63ca134e6bd28.webp)

外面:

![](https://bu.dusays.com/2023/01/20/63ca134f1f239.webp)

因为在今年换用了NOILinux2.0，编译环境不用担心。

## 代码

{% hideToggle 我已经详细看完并理解了上面的内容，并且不会直接照搬 %}

PS：C++的正则转义是双斜线`\\`，且不支持`\d`简写

```cpp
#include <bits/stdc++.h>
using namespace std;
regex ipadd("^([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9])\\.([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9])\\.([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9])\\.([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9]):([0-9]|[1-9][0-9]|[1-9][0-9]{2}|[1-9][0-9]{3}|[1-5][0-9]{4}|6[0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5])$"); //一个掉了一堆头发的范围判定正则
int main(){
	ios::sync_with_stdio(0); //读入优化（虽然没啥用
	int n,li[1145],k=1;
	string l[1145];
	cin>>n;
	for(int i=1;i<=n;i++){
		string a,b;
		cin>>a>>b;
		bool ret=regex_match(b,ipadd); //匹配正则
		if(!ret){
			cout<<"ERR"<<endl;
			continue;
		}
		if(a=="Server"){
			for(int j=1;j<=k;j++){ //找元素，开始T了以为是这里的原因调了半天还用二分卡了半天结果特么的是正则的编译位置不对
				if(l[j]==b){
					cout<<"FAIL"<<endl;
					goto end; //跳出循环
				}
			}
			li[++k]=i; //偷懒，li数组记录本来的索引
			l[k]=b;
			cout<<"OK"<<endl;
		}
		else if(a=="Client"){
			for(int j=1;j<=k;j++){
				if(l[j]==b){ //找元素，记录索引
					cout<<li[j]<<endl;
					goto end; 
				}
			}
			cout<<"FAIL"<<endl;
		}
		end: {} //不加{}会CE
	}
}


```
{% endhideToggle %}
# 解析-Python做法

这道题也可以用 Python 来做。周知所众，Python 的字符处理能力特强，效率也不低，对于这道题：对于 $100 \%$ 的数据，保证 $1 \le n \le 1000$。是完全够用的。

首先要进行字符串查错，检查 IP 地址串，根据题目要求：

1. 必须形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为非负整数；
2. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$；
3. $a, b, c, d, e$ 均不能含有多余的前导 $0$。

我们一点一点的来看。

第一点，使用一个正则表达式来匹配，只能匹配 `*.*.*.*:*` 的格式，且每一部分均为数字，不能为负号，每一位数字用正则表达式写成：`\d`，匹配多个加个 `*` ，正则表达式就写成:

`^(\d*)\.(\d*)\.(\d*)\.(\d*):(\d*)$`

其中，**首尾加`^$`表示全匹配，每一个`.`前面要加上 `\` 来转义，否则会被识别为正则表达式语法，会导致只有 $75$ 分**。

而其实，在第三点中说到：不能有前导零，要么这个数就是零，所以正则表达式的匹配可以改为(`[1-9]`表示匹配1-9的数字):

`^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*):(0|[1-9]\d*)$`


我们使用`re.match`来匹配：

```python
import re
re.match("^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*):(0|[1-9]\d*)$",str)==None #如果为None，说明不符合式子
```

第二点，我采用`split`判定范围，拆成数字之后一个一个看。

并且为了偷懒，窝写了个简简单单的列表推导式。

整个条件表达式如下
```python
re.match("^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)\.\
(0|[1-9]\d*):(0|[1-9]\d*)$",b)==None or (int(b.split(":")\
[1]) > 65535 or int(b.split(":")[1])<0) or (True in [(int(b.\
split(":")[0].split(".")[i]) > 255 or int(b.split(":")[0].split\
(".")[i]) <0) for i in range(len(b.split(":")[0].split(".")))])
# 也就亿点点长吧qwq，其实有些地方可以简化但是懒得开新列表，直接cv，搞得像加了密一样
```

然后服务器就很简单了，创建一个数组来存放之前的所有地址，如果发现重复，输出`FAIL`，不然就加到数组里面，输出`OK`。

客户端的话，只需要在前面的数组里面寻找匹配的上的服务器地址，并且输出对应的索引，{% p red, （因为默认下标是0开头的所以要加1） %}\end{sloppypar}$，然后找不到就输出FAIL，这样这道题就完成了 %}

当然除此之外，也可以用全正则表达式来匹配范围，这样子会麻烦一点，而且时间稍长，相信看得懂的都看得懂（参考上面C++做法）：

`^([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9])\\.([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9])\\.([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9])\\.([0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]|[1-9][0-9]):([0-9]|[1-9][0-9]|[1-9][0-9]{2}|[1-9][0-9]{3}|[1-5][0-9]{4}|6[0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5])$`

## 代码

{% hideToggle 我已经详细看完并理解了上面的内容，并且不会直接照搬 %}
```python
import re #别忘了
n, l, li = int(input()), [], [] #偷懒并输入
for i in range(n):
    a, b = input().split(" ") #py的输入有亿点点坑
    try:
        if re.match("^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*):(0|[1-9]\d*)$",b)==None or (int(b.split(":")[1]) > 65535 or int(b.split(":")[1])<0) or (True in [(int(b.split(":")[0].split(".")[i]) > 255 or int(b.split(":")[0].split(".")[i]) <0) for i in range(len(b.split(":")[0].split(".")))]):
            print("ERR") #代码跟加了密似的，判断条件，不满足则输出跑路
            continue 
    except:
        print("ERR") #匹配错误也是不满足
        continue
    if a == "Server":
        if b in l:
            print("FAIL") #已经存在
        else:
            print("OK")
            l.append(b) #不存在、加进去
            li.append(i) #li是记录本来的索引的
    elif a == "Client":
        if b in l:
            print(li[l.index(b)]+1) #输出索引+1
        else:
            print("FAIL") #找不到，没法连接
```
{% endhideToggle %}